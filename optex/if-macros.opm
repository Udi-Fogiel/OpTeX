%% This is part of OpTeX project, see http://petr.olsak.net/optex

\_codedecl \newif {Special if-macros, is-macros and loops <2020-04-01>} % preloaded in format

   \_doc ----------------------------
   The `\newif` macro works like in plain \TeX. It means that
   after `\newif\ifxxx` you can use `\xxxtrue` or
   `\xxxfalse` to set the boolean value and use `\ifxxx true\else false\fi`
   to test this value. The defalut value is false.

   The macro `\_newifi` enables to declare `\_ifxxx` and to use `\_xxxtrue` and
   `\_xxxfalse`. This means that it is usable for _prefixed macros.
   \_cod ----------------------------

\_def\_newif #1{\_ea\_newifA \_string #1\_relax#1}
\_ea\_def \_ea\_newifA \_string\if #1\_relax#2{%
   \_sdef{#1true}{\_let#2=\_iftrue}%
   \_sdef{#1false}{\_let#2=\_iffalse}%
   \_let#2=\_iffalse
}
\_def\_newifi #1{\_ea\_newifiA \string#1\_relax#1}
\_ea\_def \_ea\_newifiA \string\_if #1\_relax#2{%
   \_sdef{_#1true}{\_let#2=\_iftrue}%
   \_sdef{_#1false}{\_let#2=\_iffalse}%
   \_let#2=\_iffalse
}

   \_doc ----------------------------
   The `\loop <codeA> \ifsomething <codeB> \repeat` loops `<codeA> <codeB>`
   until `\ifsomething` is false. Then `<codeB>` is not executed and loop is
   finished. This works like in plain \TeX, but implementation is soewhat
   better (you can use `\else` clause after the `\ifsomething`).

   There are public version `\loop...\repeat` and private version
   `\_loop...\_repeat`. You canot mix both versions in one loop. 
   \_cod ----------------------------

\_long\_def \_loop #1\_repeat{\_def\_body{#1}\_iterate}
\_def \loop #1\repeat{\_def\_body{#1}\_iterate}
\_let \_repeat=\_fi % this makes \loop...\if...\repeat skippable
\_let \repeat=\_fi
\_def \_iterate {\_body \_ea \_iterate \_fi}


   \_doc -----------------------------
   `\foreach <list> \do {<what>}` repeats `<what>` for each element of the
   `<list>`. The `<what>` can include `#1` which is substuted by each
   element of the `<list>`. The macro is expandable.

   `\fornum <from>..<to> \do {<what>}` or `\fornum <from>..<to> \step <num> \do {<what>}`
   repeats `<what>` for each number from `<from>` to `<to>` (with step `<num>`
   or with step one). The `<what>` can include `#1` which is substituted by
   current number. The sequence `<from>..<to>` can be decreasing too.
   The macro is expandable.
   \_cod -----------------------------

\_def\_foreach #1\_do#2{\_immediateassignment\_def\_body##1{#2}\_foreachA #1\_do}
\_def\_foreachA #1{\_ifx\_do#1\_else\_body{#1}\_ea\_foreachA\_fi}
\_def\_do{\_doundefined} % we need to ask \_ifx#1\_do ...

\_def\_fornum #1\_do#2{\_immediateassignment\_def\_body##1{#2}%
   \_immediateassignment\_def\_fornumsgn{}\_immediateassignment\_def\_fornumrel{<}%
   \_fornumA #1\_relax\step1\_relax\_end}
\_def\_fornumA #1..#2\step#3\_relax#4\_end{%
   \_immediateassignment\_tmpnum=\_numexpr#1\_relax 
   \_ifnum\_numexpr#2<\_tmpnum \_immediateassignment\_def\_fornumrel{>}\_fi %decreasing
   \_ifnum\_numexpr#3\_fornumrel0 \_immediateassignment\_def\_fornumsgn{-}\_fi
   \_fornumB{#2}{#3}}
\_def\_fornumB #1#2{\_ifnum\_numexpr#1\_fornumrel\_tmpnum \_else 
   \_ea\_body\_ea{\_the\_tmpnum}%
   \_immediateassignment\_advance\_tmpnum by\_numexpr\_fornumsgn#2\_relax 
   \_afterfi{\_fornumB{#1}{#2}}\_fi}
\_def\_afterfi#1#2\_fi{\_fi#1}

\_def\foreach #1\do{\_foreach #1\_do}
\_def\fornum #1\do{\_fornum #1\_do}


   \_doc ----------------------------
   The macro `\isnextchar <char>{<codeA>}{<codeB>}` executes `<codeA>` if next
   character is equal to <char>. Else the `<codeB>` is executed. The macro is
   not expandable.
   \_cod ----------------------------

\_long\_def\_isnextchar#1#2#3{\_begingroup\_toks0={\_endgroup#2}\_toks1={\_endgroup#3}%
   \_let\_tmp=#1\_futurelet\_next\_isnextcharA
}
\_def\_isnextcharA{\_the\_toks\_ifx\_tmp\_next0\_else1\_fi\_space}

   \_doc ----------------------------
   The macro `\isempty{<text>}\iftrue <codeA>\else <codeB>\fi` executes <codeA>
   if <text> is empty and <codeB> if it is non-empty. You can use
   `\isempty{<text>}\iffalse <codeB>\else <codeA>\fi` too. This macro is
   expandable. 

   There are a collection of macros with commnon syntax:
   `\issomething<params>\iftrue` or `\issomething<params>\iffalse`.
   The `\iftrue` or `\iffalse` is a part of this syntax because we need to keep
   skippable nested `\if` conditions.

   We read this `\iftrue` or `\iffalse` into unseparated parameter and repeat
   it because we need to remove an optional space before this command.
   \_cod ----------------------------

\_def \_isempty #1#2{\_ea\_ifx\_ea\_relax\_detokenize{#1}\_relax 
    \_else \_ea\_unless \_fi #2}
\_def \_isnoempty #1#2{\_ea\_ifx\_ea\_relax\_detokenize{#1}\_relax 
    \_ea\_unless \_fi #2}
\_def \_istoksempty #1{\_ea\_isempty\_ea{\_the#1}}

   \_doc ----------------------------
   `\isequal{<textA>}{<textB>}\iftrue` is true if the <textA> and <textB> are
   equal, only from strings point of view, category codes are ignored.
   The macro is expandable.
   \_cod ----------------------------

\_def\_isequal#1#2#3{\_directlua{%
   if "\_luaescapestring{\_detokenize{#1}}"=="\_luaescapestring{\_detokenize{#2}}" 
   then else tex.print("\_nbb unless") end}#3}

   \_doc ----------------------------
   `\ismacro\macro{text}\iftrue` is true if macro is defined as {<text>}.
   Category codes are ignored in this testing. The macro is expandable.
   \_cod ----------------------------

\_def\_ismacro#1{\_ea\_isequal\_ea{#1}}

   \_doc ----------------------------
   `\isinlist\list{<text>}\iftrue` is true if the
   `<text>` is included the macro body of the `\list`. 
   The category code are relevant here. The macro is not expandable.
   \_cod ----------------------------

\_def\_isdefined #1#2{\_ifcsname #1\_endcsname \_else \_ea\_unless \_fi #2}

   \_doc ----------------------------
   `\isdefined{<csname>}\iftrue` is true if `\<csname>` is defined.
   \_cod ----------------------------

\_long\_def\_isinlist#1#2{\_begingroup 
   \_long\_def\_tmp##1#2##2\_end/_{\_endgroup\_isnoempty{##2}}%
   \_ea\_tmp#1\_endlistsep#2\_end/_%
}

   \_doc -----------------------------
   `\isfile{<filename>}\iftrue` is true if the file <filename> exists and are
   readable by \TeX.
   \_cod -----------------------------

\_newread \_testin

\_def\_isfile #1{%
   \_openin\_testin ={#1}\_relax
   \_ifeof\_testin \_ea\_unless
   \_else \_closein\_testin
   \_fi
}
\_public
   \newif \isnextchar \isempty \isequal \ismacro \isdefined \isinlist \isfile ;

\_endcode 

